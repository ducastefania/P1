# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

import numpy as np
import random
from sklearn.metrics import mutual_info_score
from sklearn.feature_selection import mutual_info_regression
from sklearn.neighbors import KNeighborsRegressor
#!pip install bnlearn
#import bnlearn as bn
import pandas as pd

# generate 4 random variables

X1 = np.random.normal(loc=0, scale=1, size=5)
X2 = np.random.normal(loc=0, scale=1, size=5) + 3 * X1
X3 = np.random.normal(loc=0, scale=1, size=5) + 5 * X2
X4 = np.random.normal(loc=0, scale=1, size=5) + 2 * X3

print(f"X1: {X1}")
print(f"X2: {X2}")
print(f"X3: {X3}")
print(f"X4: {X4}")

# function to generate random variables

def generate_random_var(mean, stDev, noSamples, noVariables):

  result = list()
  coefs = list()

  # add first value
  result.append(np.random.normal(loc=mean, scale=stDev, size=noSamples).tolist())
  coefs.append([mean, stDev])


  for i in range(1, noVariables):
    # TODO: mean - 0.5, 1.5
    # TODO: stde  -> 0.1 - 1.5
    # store coef in a list + mean, st dev
    while True:

      coef1 = random.uniform(0.1, 1)
      coef2 = random.uniform(0.1, 1)
      #
      if coef1 != 0 and coef2 != 0:
        break
    aux = coef1 * np.random.normal(loc=mean, scale=stDev, size=noSamples) + coef2 * np.array(result[i-1])
    result.append(aux.tolist())
    coefs.append([coef1, coef2])

  return result, coefs

# generate random variables incl mean and st dev

def generate_random_var_all(mean, stDev, noSamples, noVariables):

  result = list()
  coefs = list()
  meanANDstdev = list()

  # add first value
  result.append(np.random.normal(loc=mean, scale=stDev, size=noSamples).tolist())
  coefs.append([mean, stDev])
  meanANDstdev.append([mean, stDev])


  for i in range(1, noVariables):

    while True:
      coef1 = random.uniform(-1, 1)
      coef2 = random.uniform(0, 1)
      if coef1 != 0 and coef2 != 0:
        break

    coef_mean = random.uniform(0.5, 1.5)
    coef_stDev = random.uniform(0.1, 1.5)
    aux = coef1 * np.random.normal(loc=coef_mean, scale=coef_stDev, size=noSamples) + coef2 * np.array(result[i-1])
    result.append(aux.tolist())
    coefs.append([coef1, coef2])
    meanANDstdev.append([coef_mean, coef_stDev])

  return result, coefs, meanANDstdev

def generate_random_var_missig_data(mean, stDev, noSamples, noVariables, percentage):

  result, coefs = generate_random_var(mean, stDev, noSamples, noVariables)
  no_replacements = int(percentage/100 * noVariables)
  result = np.array(result)

  while no_replacements > 0:

    random_position =  random.randint(1, noVariables - 1)
    result[random_position, :] = 0
    no_replacements = no_replacements - 1

  return result.tolist(), coefs

def generate_random_var_noise_data(mean, stDev, noSamples, noVariables, percentage):

  result, coefs = generate_random_var(mean, stDev, noSamples, noVariables)
  no_replacements = int(percentage/100 * noVariables)
  result = np.array(result)

  while no_replacements > 0:

    random_position =  random.randint(1, noVariables - 1)
    coef1 = random.uniform(0.1, 1)
    result[random_position, :] = result[random_position, :] + coef1 * np.random.normal(loc=mean, scale=stDev, size=noSamples)
    no_replacements = no_replacements - 1

  return result.tolist(), coefs

def generate_random_var_hidden_data(mean, stDev, noSamples, noVariables, percentage):

  # at data generation - add z then move further to next var
   result, coefs = generate_random_var(mean, stDev, noSamples, noVariables)
   no_replacements = int(percentage/100 * noVariables)
   result = np.array(result)
   z = np.random.normal(loc=mean, scale=stDev, size=noSamples)

   while no_replacements > 0:

      random_position =  random.randint(1, noVariables - 1)
      result[random_position, :] = result[random_position, :] + z
      no_replacements = no_replacements - 1

   return result.tolist(), coefs

# function to return the MI matrix

def get_MI_matrix(data, noVariables):
  data = np.array(data).T
  mi_matrix = np.zeros((noVariables, noVariables))
  for i in range(noVariables):
    for j in range(i, noVariables):
       if i == j:
                mi = 0
       else:
          mi = mutual_info_regression(data[:, [i]], data[:, j])[0]
          mi_matrix[i, j] = mi_matrix[j, i] = mi

  return mi_matrix

# function to return the MI matrix - second

def get_MI_matrix(data, noVariables):
  data = np.array(data).T
  mi_matrix = np.zeros((noVariables, noVariables))
  for i in range(noVariables):
    for j in range(i, noVariables):
       if i == j:
                mi = 0
       else:
          mi = mutual_info_regression(data[:, [i]], data[:, j])[0]
          mi_matrix[i, j] = mi_matrix[j, i] = mi

  return mi_matrix

def hillclimb(data, noVariables):

  df = pd.DataFrame(data)
  print(df)
  model = bn.structure_learning.fit(df, methodtype='hc', scoretype='k2')
  print("Chain:")
  G = bn.plot(model, params_static={'figsize': (25, 15), 'dpi': 300, 'font_size': 18}, edge_labels=None)

# function to return Corr Matrix

def get_corr_matrix(data):
  data = np.array(data).T
  corr_matrix = np.corrcoef(data, rowvar=False)

  return corr_matrix

def create_chain(mi_matrix, noVariables):

    result = list()
    mi_chain_sums = list()

     # consider each variable as start node
    for i in range(0, noVariables):
      # variable to create the chain
      chain = list()
      chain.append(i)
      # keep track of who is not in the chain yet
      unvisited = list(range(0, noVariables))
      unvisited.remove(i)

      chain_sum = 0
      aux = i

      # Create the chain
      # for each variable considered first, i.e. for each chain we do this:
      # have a list of variables that are not in the chain
      # find the max on the column including only the variables not in the chain
      # add the corresponding variable to the chain, update the sum along the chain
      # remove the variable from the unvisited list

      while len(unvisited) != 0:
        max_value = 0
        index = -1

        for j in unvisited:
          if mi_matrix[aux][j] > max_value:
            max_value = mi_matrix[aux][j]
            index = j

        chain.append(index)
        chain_sum += max_value
        unvisited.remove(index)
        aux = index

      result.append(chain)
      mi_chain_sums.append(chain_sum)

    return result, mi_chain_sums

def create_chain_zeros(mi_matrix, noVariables):

    result = list()
    mi_chain_sums = list()

     # consider each variable as start node
    for i in range(0, noVariables):
      # variable to create the chain
      chain = list()
      chain.append(i)
      # keep track of who is not in the chain yet
      unvisited = list(range(0, noVariables))


      chain_sum = 0
      aux = i

      # Create the chain
      # for each variable considered first, i.e. for each chain we do this:
      # have a list of variables that are not in the chain
      # find the max on the column including only the variables not in the chain
      # add the corresponding variable to the chain, update the sum along the chain
      # remove the variable from the unvisited list
      while len(chain) != noVariables -1 :
        max_value = 0
        index = -1

        for j in unvisited:
          if mi_matrix[aux][j] >= max_value and j not in chain:
            max_value = mi_matrix[aux][j]
            index = j
        chain.append(index)
        chain_sum += max_value
        unvisited.remove(index)
        aux = index

      result.append(chain)
      mi_chain_sums.append(chain_sum)

    return result, mi_chain_sums

# choose best chain(s)

def choose_chain(chains, mi_chain_sums):

  max_chains = list()
  max_chain_sum = 0

  for i in range(0, len(mi_chain_sums)):
    sum = mi_chain_sums[i]
    if sum > max_chain_sum:
      max_chain_sum = sum
      max_chains = chains[i]

  print(max_chains)
  return max_chains, max_chain_sum

# Accuracy Function

def acc_func(result, test_chain):

  count = 0

  for i in range(len(result)):
        if result[i] == test_chain[i]:
            count += 1

  return count/len(result)

# Print chain

def print_chain(chain):

  result = "X" + str(chain[0])

  for i in range(1, len(chain)):
    result += " -> X" + str(chain[i])

  print(result)

# functions to test

# case 1: stDev = 1, mean = 0
def case1(mean, stDev, noSamples, noVariables):

  data = list()
  data, coefs =  generate_random_var(mean, stDev, noSamples, noVariables)
  print(f"Data:\n {data}")
  print(f"Coefs:\n {coefs}")

  mi_mat = get_MI_matrix(data, noVariables)
  print(f"MI Matrix:\n {mi_mat}")

  mi_chains, mi_chain_sums = create_chain(mi_mat, noVariables)
  print(f"Chains:\n {mi_chains}")
  print(f"Chain sum for each chain:\n {mi_chain_sums}")

  mi_max_chain, mi_max_chain_sum = choose_chain(mi_chains, mi_chain_sums)
  print(f"Maximum chains:\n {mi_max_chain}")
  print_chain(mi_max_chain)
  print(f"Maximum sum along the chain:\n {mi_max_chain_sum}")

  original_chain = list()
  for i in range(0, noVariables):
    original_chain.append(i)

  mi_acc = acc_func(mi_max_chain, original_chain)
  print(f"Accuracy:  {mi_acc}")

  corr_mat = get_corr_matrix(data)
  print(f"Corr Matrix:\n {corr_mat}")

  corr_chains, corr_chain_sums = create_chain(corr_mat, noVariables)
  print(f"Chains:\n {corr_chains}")
  print(f"Chain sum for each chain:\n {corr_chain_sums}")

  corr_max_chain, corr_max_chain_sum = choose_chain(corr_chains, corr_chain_sums)
  print(f"Maximum chains:\n {corr_max_chain}")
  print_chain(corr_max_chain)
  print(f"Maximum sum along the chain:\n {corr_max_chain_sum}")

  corr_acc = acc_func(corr_max_chain, original_chain)
  print(f"Accuracy:  {corr_acc}")


# case 2: random stDev, random mean
def case2(mean, stDev, noSamples, noVariables):

  data = list()
  data, coefs, meanANDstdev =  generate_random_var_all(mean, stDev, noSamples, noVariables)

  print(f"Data:\n {data}")
  print(f"Coefs:\n {coefs}")
  print(f"Means and st deviations:\n {meanANDstdev}")

 # print(data[])

  mi_mat = get_MI_matrix(data, noVariables)
  print(f"MI Matrix:\n {mi_mat}")

  mi_chains, mi_chain_sums = create_chain(mi_mat, noVariables)
  print(f"Chains:\n {mi_chains}")
  print(f"Chain sum for each chain:\n {mi_chain_sums}")

  mi_max_chain, mi_max_chain_sum = choose_chain(mi_chains, mi_chain_sums)
  print(f"Maximum chains:\n {mi_max_chain}")
  print_chain(mi_max_chain)
  print(f"Maximum sum along the chain:\n {mi_max_chain_sum}")

  original_chain = list()
  for i in range(0, noVariables):
    original_chain.append(i)

  mi_acc = acc_func(mi_max_chain, original_chain)
  print(f"Accuracy:  {mi_acc}")

  corr_mat = get_corr_matrix(data)
  print(f"Corr Matrix:\n {corr_mat}")

  corr_chains, corr_chain_sums = create_chain(corr_mat, noVariables)
  print(f"Chains:\n {corr_chains}")
  print(f"Chain sum for each chain:\n {corr_chain_sums}")

  corr_max_chain, corr_max_chain_sum = choose_chain(corr_chains, corr_chain_sums)
  print(f"Maximum chains:\n {corr_max_chain}")
  print_chain(corr_max_chain)
  print(f"Maximum sum along the chain:\n {corr_max_chain_sum}")

  corr_acc = acc_func(corr_max_chain, original_chain)
  print(f"Accuracy:  {corr_acc}")

# case 3: leave xi = [0 0 0 ...] (5% of data, 10%, 20%)
def case3(mean, stDev, noSamples, noVariables, percent):

  data, coefs= generate_random_var_missig_data(0, 1, noSamples, noVariables, 20)
  print(f"Data:\n {data}")
  print(f"Coefs:\n {coefs}")

  mi_mat = get_MI_matrix(data, noVariables)
  print(f"MI Matrix:\n {mi_mat}")

  mi_chains, mi_chain_sums = create_chain_zeros(mi_mat, noVariables)
  print(f"Chains:\n {mi_chains}")
  print(f"Chain sum for each chain:\n {mi_chain_sums}")

  mi_max_chain, mi_max_chain_sum = choose_chain(mi_chains, mi_chain_sums)
  print(f"Maximum chains:\n {mi_max_chain}")
  print_chain(mi_max_chain)
  print(f"Maximum sum along the chain:\n {mi_max_chain_sum}")

  original_chain = list()
  for i in range(0, noVariables):
    original_chain.append(i)

  mi_acc = acc_func(mi_max_chain, original_chain)
  print(f"Accuracy:  {mi_acc}")

  corr_mat = get_corr_matrix(data)
  print(f"Corr Matrix:\n {corr_mat}")

  corr_chains, corr_chain_sums = create_chain(corr_mat, noVariables)
  print(f"Chains:\n {corr_chains}")
  print(f"Chain sum for each chain:\n {corr_chain_sums}")

  corr_max_chain, corr_max_chain_sum = choose_chain(corr_chains, corr_chain_sums)
  print(f"Maximum chains:\n {corr_max_chain}")
  print_chain(corr_max_chain)
  print(f"Maximum sum along the chain:\n {corr_max_chain_sum}")

  corr_acc = acc_func(corr_max_chain, original_chain)
  print(f"Accuracy:  {corr_acc}")


#case 4: add random extra noise
def case4(mean, stDev, noSamples, noVariables, percent):

  data = list()
  data, coefs= generate_random_var_noise_data(mean, stDev, noSamples, noVariables, percent)
  print(f"Data:\n {data}")
  print(f"Coefs:\n {coefs}")

  mi_mat = get_MI_matrix(data, noVariables)
  print(f"MI Matrix:\n {mi_mat}")

  mi_chains, mi_chain_sums = create_chain(mi_mat, noVariables)
  print(f"Chains:\n {mi_chains}")
  print(f"Chain sum for each chain:\n {mi_chain_sums}")

  mi_max_chain, mi_max_chain_sum = choose_chain(mi_chains, mi_chain_sums)
  print(f"Maximum chains:\n {mi_max_chain}")
  print_chain(mi_max_chain)
  print(f"Maximum sum along the chain:\n {mi_max_chain_sum}")

  original_chain = list()
  for i in range(0, noVariables):
    original_chain.append(i)

  mi_acc = acc_func(mi_max_chain, original_chain)
  print(f"Accuracy:  {mi_acc}")

  corr_mat = get_corr_matrix(data)
  print(f"Corr Matrix:\n {corr_mat}")

  corr_chains, corr_chain_sums = create_chain(corr_mat, noVariables)
  print(f"Chains:\n {corr_chains}")
  print(f"Chain sum for each chain:\n {corr_chain_sums}")

  corr_max_chain, corr_max_chain_sum = choose_chain(corr_chains, corr_chain_sums)
  print(f"Maximum chains:\n {corr_max_chain}")
  print_chain(corr_max_chain)
  print(f"Maximum sum along the chain:\n {corr_max_chain_sum}")

  corr_acc = acc_func(corr_max_chain, original_chain)
  print(f"Accuracy:  {corr_acc}")

# case 5: add z noise
def case5(mean, stDev, noSamples, noVariables, percent):

  data = list()
  data, coefs= generate_random_var_hidden_data(mean, stDev, noSamples, noVariables, percent)
  print(f"Data:\n {data}")
  print(f"Coefs:\n {coefs}")

  mi_mat = get_MI_matrix(data, noVariables)
  print(f"MI Matrix:\n {mi_mat}")

  mi_chains, mi_chain_sums = create_chain(mi_mat, noVariables)
  print(f"Chains:\n {mi_chains}")
  print(f"Chain sum for each chain:\n {mi_chain_sums}")

  mi_max_chain, mi_max_chain_sum = choose_chain(mi_chains, mi_chain_sums)
  print(f"Maximum chains:\n {mi_max_chain}")
  print_chain(mi_max_chain)
  print(f"Maximum sum along the chain:\n {mi_max_chain_sum}")

  original_chain = list()
  for i in range(0, noVariables):
    original_chain.append(i)

  mi_acc = acc_func(mi_max_chain, original_chain)
  print(f"Accuracy:  {mi_acc}")

  corr_mat = get_corr_matrix(data)
  print(f"Corr Matrix:\n {corr_mat}")

  corr_chains, corr_chain_sums = create_chain(corr_mat, noVariables)
  print(f"Chains:\n {corr_chains}")
  print(f"Chain sum for each chain:\n {corr_chain_sums}")

  corr_max_chain, corr_max_chain_sum = choose_chain(corr_chains, corr_chain_sums)
  print(f"Maximum chains:\n {corr_max_chain}")
  print_chain(corr_max_chain)
  print(f"Maximum sum along the chain:\n {corr_max_chain_sum}")

  corr_acc = acc_func(corr_max_chain, original_chain)
  print(f"Accuracy:  {corr_acc}")

# result : X1 -> X2 -> ,.... DONE
# TODO: accuracy func DONE

# TODO: for first node: variance(node) min orr?
# TODO: which node is the first


#-----

# use correlation matrix instead of MI matrix - DONE

# MI vs corr mat - more robust? - check acc
# hill climb heuristics -> BN learn -> ill get chain

# from data - leave xi = [0 0 0 ...] (5% of data, 10%, 20%) - algos still work? - DONE
#chain before replacement vs chain after replacement acc?

# from data - leave xi = [add some extra noise with stdev = 0.1, ...] (5% of data, 10%, 20%) - algos still work?
#chain before replacement vs chain after replacement acc?

# other thing to test:
# adda another var "hidden" : z = N(0, 1), in 2 of the var x1 = x1 + z , x2 = x2 + z (z is not in data set) - > compare results for algo, acc?

# plot data - x = acc y = share of missing variables (5 % 10% ,, )

# test functions

noVariables = 5
noSamples = 10
mean = 0
stDev = 1

#case1(mean, stDev, noSamples, noVariables)
case2(mean, stDev, noSamples, noVariables)

percent = 20
#case3(mean, stDev, noSamples, noVariables, percent)
#case4(mean, stDev, noSamples, noVariables, percent)
#case5(mean, stDev, noSamples, noVariables, percent)

# replace 0s,
# plots to show diffs
# plots - results next to each other when changing percent - all funcs
# for dif sample sizes noFeatueres= (100, 1000)
# hillclimb
# plot:y:  acc/ x: each case - bar
